// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Calculate

const int Tolerance = 100000;
int size;
float angle;
float3 triNormals[5000];

struct VertexKey
{
	int _x;
	int _y;
	int _z;
};

class VertexEntry
{
	int TriangleIndex[4];
	int VertexIndex[4];
};



// VertexEntry data buffer
StructuredBuffer<VertexEntry> dataBuffer;

RWStructuredBuffer<float3> normals;

//[numthreads(8,8,1)]
[numthreads(10,1,1)]
void Calculate (uint3 id : SV_DispatchThreadID)
{
	// TODO: insert actual code here!

	//Result[id.xy] = float4(id.x & id.y, (id.x & 15)/15.0, (id.y & 15)/15.0, 0.0);
	VertexEntry vxEntry = dataBuffer[id.x];
	for (int i = 0; i < size; ++i)
	{
		float3 sum;
		// For each other triangle T2 (including self) that point belongs to
		for (int j = 0; j < size; ++j)
		{
			// The corresponding vertex is actually the same vertex
			if (vxEntry.VertexIndex[i] == vxEntry.VertexIndex[j])
			{
				// Add to temporary Vector3
				sum += triNormals[vxEntry.TriangleIndex[j]];
			}
			else
			{
				float dotProduct = dot(
					triNormals[vxEntry.TriangleIndex[i]],
					triNormals[vxEntry.TriangleIndex[j]]);
				dotProduct = clamp(dotProduct, -0.99999f, 0.99999f);
				float acosVal = acos(dotProduct);
				// The angle between the two triangles is less than the smoothing angle
				if (acosVal <= angle)
				{
					// Add to temporary Vector3
					sum += triNormals[vxEntry.TriangleIndex[j]];
				}
			}
		}
		// Normalize temporary Vector3 to find the average
		normals[vxEntry.VertexIndex[i]] = normalize(sum);

		//sum = Vector3.zero;
	}
}